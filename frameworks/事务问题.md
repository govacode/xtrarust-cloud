```java
@Service
public class ServiceImpl {

    // 这种是不会失效的 @Transactional要生效需要是代理类调用过来
    // 自身调用 方法入口处没有事务注解 内部this调用的方法才加事务注解会失效
    @Transactional(rollbackFor = Exception.class)
    public void methodA() {
        // mapper操作

        this.methodB();
    }

    public void methodB() {

    }
}
```

```java
@Service
public class OrderServiceImpl implements OrderService {
    
    // 分析：任何一步失败则事务回滚 造成影响无非是用户体验不好
    // 第1、2、3步执行成功 此时短信或MQ消息已发送 
    // 但是数据库事务提交时异常（如数据库出现了问题）第1、2步可以回滚 但是短信或MQ已发送
    // 如果第三步发送的MQ消息 可能还会出现消息消费时事务尚未提交 导致无法看到数据库的变更
    // 前两步是数据库操作 要么成功要么失败 而第三步是辅助性操作 事务无法保证数据库操作与外部操作的一致性
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        // 1. 创建订单
        doCreateOrder(order);
        // 2. 增加积分
        addPoints(order);
        // 3. 发送短信 or 发送MQ消息
        sendSms();
    }
}
```
解决方法：
- Spring事务监听（原理见 `TransactionalEventListenerFactory`）
- 手动注册事务同步
- 利用TransactionTemplate手动管理事务

``` java
@Service
public class OrderServiceImpl implements OrderService {
    
    @Resource
    private ApplicationEventPublisher applicationEventPublisher;
    
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        // 1. 创建订单
        doCreateOrder(order);
        // 2. 增加积分
        addPoints(order);
        // 3. 发送短信 or 发送MQ消息
        applicationEventPublisher.publishEvent(new SmsEvent(order));
    }
}

@Component
public class SmsEventListener {
    
    @Resource
    private SmsService smsService;
    
    // fallbackExecution 若没有事务的时候，对应的event是否需要执行
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, fallbackExecution = false, classes = SmsEvent.class)
    public void onSmsEvent(SmsEvent smsEvent) {
        smsService.sendSms(smsEvent.getOrder());
    }
}
```

``` java
@Service
public class OrderServiceImpl implements OrderService {
    
    @Resource
    private ApplicationEventPublisher applicationEventPublisher;
    
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        // 1. 创建订单
        doCreateOrder(order);
        // 2. 增加积分
        addPoints(order);
        
        // TransactionSynchronizationManager#isSynchronizationActive 可以判断是否有事务 可以用来兼容没事务的场景
        // if (!TransactionSynchronizationManager.isSynchronizationActive()) { // 没事务异步操作 } else { // 有事务注册同步器执行异步操作 } 
        TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
            @Override
            public void afterCommit() {
                // 3. 发送短信 or 发送MQ消息
                
            }
        });
    }
}
```

``` java
@Service
public class OrderServiceImpl implements OrderService {
    
    @Resource
    private TransactionTemplate transactionTemplate;
    
    @Resource
    private ApplicationEventPublisher applicationEventPublisher;
    
    public void createOrder(Order order) {
        Boolean executed = transactionTemplate.execute(status -> {
            // 1. 创建订单
            doCreateOrder(order);
            // 2. 增加积分
            addPoints(order);
            return true;
        });
        if (Boolean.TRUE.equals(executed)){
            applicationEventPublisher.publishEvent(new SmsEvent(order));
        }
    }
}
```

幂等
往往有流水表

- 根据流水状态 update table set status = 1 where id = xxx and status =0 更新失败则直接幂等返回
- version 乐观锁 update table set status = 1, version = version + 1 where id = xxx and version = #{v} 更新失败则直接幂等返回
- 表中添加idempotent_key字段并添加唯一约束 需要catch住唯一键冲突异常 幂等返回（可以额外改一个幂等表 封装后业务通用）
  - 先根据幂等键查询幂等记录 若存在直接返回
  - 开启事务
  - 执行业务操作
  - 插入幂等记录
  - 提交事务
- 分布式锁