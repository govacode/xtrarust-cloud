package com.xtrarust.cloud.auth.config;import com.xtrarust.cloud.auth.config.properties.AuthServerSecurityProperties;import com.xtrarust.cloud.auth.security.authentication.form.mfa.DefaultMfaService;import com.xtrarust.cloud.auth.security.authentication.form.mfa.MfaService;import com.xtrarust.cloud.auth.security.authentication.handler.RestSavedRequestAwareAuthenticationSuccessHandler;import com.xtrarust.cloud.auth.security.authentication.handler.RestSimpleAuthenticationFailureHandler;import com.xtrarust.cloud.auth.security.configurers.InitializeMobileUserDetailsBeanManagerConfigurer;import com.xtrarust.cloud.auth.security.configurers.MobileSmsCodeLoginConfigurer;import com.xtrarust.cloud.auth.security.configurers.UsernamePasswordLoginConfigurer;import com.xtrarust.cloud.auth.security.context.TTLSecurityContextHolderStrategy;import com.xtrarust.cloud.auth.security.oauth2.client.endpoint.AuthorizationRequestCustomizer;import com.xtrarust.cloud.auth.security.oauth2.client.endpoint.DelegatingOAuth2AccessTokenResponseClient;import com.xtrarust.cloud.auth.security.oauth2.client.handler.FederatedIdentityAuthenticationSuccessHandler;import com.xtrarust.cloud.auth.security.oauth2.client.userinfo.DelegatingOAuth2UserService;import com.xtrarust.cloud.auth.security.oauth2.server.resource.CustomBearerTokenAccessDeniedHandler;import com.xtrarust.cloud.auth.security.oauth2.server.resource.CustomBearerTokenAuthenticationEntryPoint;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.config.MethodInvokingFactoryBean;import org.springframework.boot.autoconfigure.security.servlet.PathRequest;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.http.HttpMethod;import org.springframework.http.MediaType;import org.springframework.security.config.Customizer;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.session.SessionRegistry;import org.springframework.security.crypto.factory.PasswordEncoderFactories;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;import org.springframework.security.oauth2.client.web.DefaultOAuth2AuthorizationRequestResolver;import org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter;import org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestResolver;import org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter;import org.springframework.security.oauth2.core.user.OAuth2User;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.access.AccessDeniedHandlerImpl;import org.springframework.security.web.access.DelegatingAccessDeniedHandler;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.security.web.authentication.RememberMeServices;import org.springframework.security.web.csrf.CsrfException;import org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher;import org.springframework.security.web.session.HttpSessionEventPublisher;import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher;import org.springframework.session.data.redis.RedisIndexedSessionRepository;import org.springframework.session.security.SpringSessionBackedSessionRegistry;import org.springframework.session.security.web.authentication.SpringSessionRememberMeServices;import java.util.Collections;import java.util.LinkedHashMap;import java.util.Map;import java.util.function.BiConsumer;/** * Spring Security配置 * * @author gova */@Slf4j@Configuration(proxyBeanMethods = false)@EnableWebSecurity(debug = true)@EnableMethodSecurity(prePostEnabled = true, jsr250Enabled = true, securedEnabled = true)@EnableConfigurationProperties(AuthServerSecurityProperties.class)@RequiredArgsConstructorpublic class DefaultSecurityConfig {    private static final String[] IGNORE_PATHS = {            "/**/*.html", "/**/*.css", "/**/*.js", "/**/font/**", "/**/images/**", "/**/favicon.ico",            "/webjars/**", "/doc.html", "/swagger-resources/**", "/swagger-ui.html", "/**/api-docs/**", "/**/swagger-ui/**",            "/actuator", "/actuator/**", "/.well-known/appspecific/**"    };    private final AuthServerSecurityProperties securityProperties;    private final ClientRegistrationRepository clientRegistrationRepository;    private final BiConsumer<String, OAuth2User> oauth2UserHandler;    /**     * 声明调用 {@link SecurityContextHolder#setStrategyName(String)} 方法，     * 设置使用 {@link TTLSecurityContextHolderStrategy} 作为 Security 的上下文策略     */    @Bean    public MethodInvokingFactoryBean securityContextHolderMethodInvokingFactoryBean() {        MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean();        factoryBean.setTargetClass(SecurityContextHolder.class);        factoryBean.setTargetMethod("setStrategyName");        factoryBean.setArguments(TTLSecurityContextHolderStrategy.class.getName());        return factoryBean;    }    /**     * 使用 DelegatingPasswordEncoder     */    @Bean    public PasswordEncoder passwordEncoder() {        return PasswordEncoderFactories.createDelegatingPasswordEncoder();    }    @Bean    public WebSecurityCustomizer webSecurityCustomizer() {        return web -> web.ignoring()                // 放行静态资源/css/**、/js/**、/images/**、/webjars/**、/**/favicon.ico、/fonts/** 不走Spring Security过滤器链                .requestMatchers(PathRequest.toStaticResources().atCommonLocations())                // 放行自定义url                .requestMatchers(IGNORE_PATHS);    }    // mfa多因子认证服务    @Bean    public MfaService mfaService(RedisTemplate<String, Object> redisTemplate) {        return new DefaultMfaService(redisTemplate);    }    @Bean    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http, RememberMeServices rememberMeServices) throws Exception {        // 允许加载同源域名下的iframe页面        http.headers(headers -> headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin));        // 禁用basic认证        http.httpBasic(AbstractHttpConfigurer::disable);        // csrf 相关接口与类：CsrfToken、DefaultCsrfToken、CsrfTokenRepository、CsrfFilter        http.csrf(Customizer.withDefaults());        // 授权配置（AuthorizationFilter已取代FilterSecurityInterceptor）        // When authorizeHttpRequests is used instead of authorizeRequests, then AuthorizationFilter is used instead of FilterSecurityInterceptor.        http.securityMatcher("/**")                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests                        .requestMatchers(securityProperties.getIgnoreUriList().toArray(new String[0])).permitAll()                        .anyRequest().authenticated()                );        // 记住我配置        // 1. 基于hash的简单token TokenBasedRememberMeServices        // 2. 基于jdbc的持久化token PersistentTokenBasedRememberMeServices        // 以上两个均4继承自`AbstractRememberMeServices`基于cookie实现        // 3. 基于spring session的`SpringSessionRememberMeServices`则是直接增大了session过期时间        // 因为SecurityContextHolderFilter可以直接从session获取SecurityContext RememberMeAuthenticationFilter也可以直接拿到Authentication对象        http.rememberMe(rememberMe -> rememberMe.rememberMeServices(rememberMeServices));        // 退出登录配置        http.logout(logout -> logout                .logoutRequestMatcher(PathPatternRequestMatcher.withDefaults().matcher(HttpMethod.POST, "/logout"))                .deleteCookies()                .clearAuthentication(true)                .invalidateHttpSession(true));        // 异常处理配置 ExceptionTranslationFilter        AccessDeniedHandlerImpl accessDeniedHandler = new AccessDeniedHandlerImpl();        accessDeniedHandler.setErrorPage("/403");        MediaTypeRequestMatcher htmlRequestMatcher = new MediaTypeRequestMatcher(MediaType.TEXT_HTML);        htmlRequestMatcher.setIgnoredMediaTypes(Collections.singleton(MediaType.ALL));        http.exceptionHandling(exceptions -> exceptions                .defaultAccessDeniedHandlerFor(accessDeniedHandler, htmlRequestMatcher));        // 应用自定义配置（使用自定义Configurer进行配置 支持链式调用 而不是硬编码创建过滤器再调用addFilter方法插入到Spring Security过滤器链中）        // 默认认证成功处理器为 SavedRequestAwareAuthenticationSuccessHandler        AuthenticationSuccessHandler successHandler = new RestSavedRequestAwareAuthenticationSuccessHandler();        AuthenticationFailureHandler failureHandler = new RestSimpleAuthenticationFailureHandler();        http.with(new UsernamePasswordLoginConfigurer<>(), configurer ->                configurer.loginPage("/login")                        .loginProcessingUrl("/login/pwd")                        .captchaEnabled(securityProperties.getCaptcha().getEnable())                        .successHandler(successHandler)                        .failureHandler(failureHandler));        http.with(new MobileSmsCodeLoginConfigurer<>(), configurer ->                configurer.loginProcessingUrl("/login/sms")                        .successHandler(successHandler)                        .failureHandler(failureHandler));        // Oauth2三方登录配置        // 核心组件：        // OAuth2AuthorizationRequestRedirectFilter 默认拦截端点/oauth2/authorization/{registrationId} 重定向至三方Oauth2授权页        // OAuth2LoginAuthenticationFilter 继承自AbstractAuthenticationProcessingFilter会走Spring Security核心登录认证流程        // - OAuth2LoginAuthenticationProvider 处理授权码回调 授权码换access_token后获取用户信息最终封装OAuth2LoginAuthenticationToken        // - OidcAuthorizationCodeAuthenticationProvider 处理scope含有openid的OIDC回调        // 由于默认使用 HttpSessionOAuth2AuthorizationRequestRepository 保存及加载授权请求 集群化部署需要分布式session支持（本工程已集成Spring Session）        // 默认使用 InMemoryClientRegistrationRepository 保存Oauth2客户端注册信息 如果需要可替换为数据库存储        // 详细配置阅读 OAuth2LoginConfigurer java doc及源码        http.oauth2Login(oauth2Login -> oauth2Login                .loginPage("/login")                // 授权端点  授权端点配置用于构建OAuth2AuthorizationRequestRedirectFilter 授权端点配置                .authorizationEndpoint(config -> config.authorizationRequestResolver(authorizationRequestResolver()))                // 重定向端点配置 用于配置OAuth2LoginAuthenticationFilter处理url 默认 /login/oauth2/code/*                .redirectionEndpoint(config -> config.baseUri(OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI))                // token端点配置 用于构建 OAuth2LoginAuthenticationProvider                .tokenEndpoint(config -> config.accessTokenResponseClient(new DelegatingOAuth2AccessTokenResponseClient()))                // 用户信息端点配置                .userInfoEndpoint(config -> config.userService(new DelegatingOAuth2UserService()))                // 扩展三方用户保存逻辑                .successHandler(federatedIdentityAuthenticationSuccessHandler())                .failureHandler(new RestSimpleAuthenticationFailureHandler())        );        // Oauth2客户端配置        // 核心组件：OAuth2AuthorizationRequestRedirectFilter、OAuth2AuthorizationCodeGrantFilter        // 与oauth2Login异同：oauth2Login的OAuth2LoginAuthenticationFilter在获取access_token后会获取用户信息且继承自AbstractAuthenticationProcessingFilter会走Spring Security核心登录认证流程        // 而oauth2Client的 OAuth2AuthorizationCodeGrantFilter 仅会在获取access_token重定向至redirect_uri//        http.oauth2Client(oauth2Client -> oauth2Client.authorizationCodeGrant()//                .authorizationRequestResolver(authorizationRequestResolver)//                .accessTokenResponseClient(new DelegatingAuthorizationCodeTokenResponseClient()));        // 资源服务器配置        // 核心类：BearerTokenAuthenticationFilter、JwtAuthenticationProvider、JwtGrantedAuthoritiesConverter        http.oauth2ResourceServer(oauth2ResourceServer ->                oauth2ResourceServer                        .jwt(Customizer.withDefaults())                        .authenticationEntryPoint(new CustomBearerTokenAuthenticationEntryPoint())                        .accessDeniedHandler(                                new DelegatingAccessDeniedHandler(                                        new LinkedHashMap<>(Map.of(CsrfException.class, new AccessDeniedHandlerImpl())),                                        new CustomBearerTokenAccessDeniedHandler()                                )                        )        );        return http.build();    }    private OAuth2AuthorizationRequestResolver authorizationRequestResolver() {        DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver =                new DefaultOAuth2AuthorizationRequestResolver(                        clientRegistrationRepository,                        OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI                );        // 兼容微信授权请求        authorizationRequestResolver.setAuthorizationRequestCustomizer(AuthorizationRequestCustomizer::customize);        return authorizationRequestResolver;    }    private AuthenticationSuccessHandler federatedIdentityAuthenticationSuccessHandler() {        FederatedIdentityAuthenticationSuccessHandler successHandler = new FederatedIdentityAuthenticationSuccessHandler();        successHandler.setOauth2UserHandler(oauth2UserHandler);        return successHandler;    }    // session并发控制必须 否则Spring Security将无法感知到session创建及销毁事件    @Bean    public HttpSessionEventPublisher httpSessionEventPublisher() {        return new HttpSessionEventPublisher();    }    // 当`spring.session.redis.repository-type`配置为`indexed`时会自动创建`RedisIndexedSessionRepository`Bean    // `RedisIndexedSessionRepository`会监听session的创建、删除及过期事件    // spring:session:event:0:created:c6a175af-74e2-4354-9de1-35a6d9c99bda    @Bean    public SessionRegistry sessionRegistry(RedisIndexedSessionRepository sessionRepository) {        return new SpringSessionBackedSessionRegistry<>(sessionRepository);    }    @Bean    public RememberMeServices rememberMeServices() {        SpringSessionRememberMeServices rememberMeServices = new SpringSessionRememberMeServices();        // 默认 DEFAULT_REMEMBERME_PARAMETER = "remember-me"        rememberMeServices.setRememberMeParameterName("remember-me");        // 默认30天 THIRTY_DAYS_SECONDS = 2592000;        rememberMeServices.setValiditySeconds(1209600); // 两周        return rememberMeServices;    }    // 用于配置 MobileSmsCodeAuthenticationProvider    @Bean    public InitializeMobileUserDetailsBeanManagerConfigurer initializeMobileUserDetailsBeanManagerConfigurer(ApplicationContext context) {        return new InitializeMobileUserDetailsBeanManagerConfigurer(context);    }}